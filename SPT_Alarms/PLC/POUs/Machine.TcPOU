<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.12">
  <POU Name="Machine" Id="{66cc6e36-2ea9-4621-bedd-f5d531d191bf}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK Machine EXTENDS FB_PackML_BaseModule
VAR
	EquipOne	: EquipmentModule			   := (Name := 'Equip One');
	EquipTwo	: EquipmentModuleWithSubModule := (Name := 'Equip Two');
	ComponentMM : Component					   := (Name := 'Component MM');

	//Alarms
	MachineAlarms : ARRAY[1..MACHINE_ALARM_COUNT] OF FB_TcAlarm;
	testCritical  : BOOL;
	testVerbose	  : BOOL;
END_VAR

VAR CONSTANT
	MACHINE_ALARM_COUNT : UDINT := 6; //First is InitReferenceEvent
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="Clearing" Id="{218ba0d7-e931-4a28-8ae7-0db360a35c2d}">
      <Declaration><![CDATA[METHOD PROTECTED Clearing
VAR
	i				: UDINT;
	SubModulesReady : BOOL := TRUE;
	ComponentsReady : BOOL := TRUE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
	If there are no Components of the Machine
	then we can clear the Machine Alarms and let the SUPER handle the rest.
	
	But if the Machine Module has a component
	then the process of clearing the alarms 
	must be handled in a slightly different manner.
	This will prevent an existing alarm condition that is still TRUE
	from being cleared and raised multiple times.
*)
IF NumberOfComponents = 0 THEN
	F_ClearAllEventsInClass(Alarms := MachineAlarms);
	SUPER^.Clearing();
ELSE
	CASE SequenceState OF
		0:
			F_ClearAllEventsInClass(Alarms := MachineAlarms);
			SequenceState := SequenceState + 10;

		10:
			FOR i := 1 TO NumberOfSubModules DO
				ipSubModules[i].StateCommand := E_PMLCommand.Clear;
			END_FOR

			IF BaseAlarms[E_BaseAlarms.ComponentError].bRaised THEN
				BaseAlarms[E_BaseAlarms.ComponentError].Clear(0, 0);
			END_IF;

			IF BaseAlarms[E_BaseAlarms.SubModuleError].bRaised THEN
				BaseAlarms[E_BaseAlarms.SubModuleError].Clear(0, 0);
			END_IF;

			SequenceState := SequenceState + 10;

		20:
			FOR i := 1 TO NumberOfComponents DO
				IF Parameters_PackML_Base.RESET_COMPONENTS_WITHOUT_ERROR THEN
					ipComponents[i].Reset();
				ELSE
					IF ipComponents[i].Error THEN
						ipComponents[i].Reset();
					END_IF
				END_IF
			END_FOR

			FOR i := 1 TO NumberOfComponents DO
				ComponentsReady := ComponentsReady AND NOT ipComponents[i].Error;
			END_FOR

			IF ComponentsReady THEN
				SequenceState := SequenceState + 10;
			END_IF

		30:
			FOR i := 1 TO NumberOfSubModules DO
				SubModulesReady := SubModulesReady AND (ipSubModules[i].CurrentState = E_PMLState.Stopped);
			END_FOR

			IF SubModulesReady AND (StateTasksComplete OR NoStateTasksToComplete) THEN
				NoStateTasksToComplete := TRUE;
				StateTasksComplete	   := FALSE;
				StateComplete();
			END_IF
	END_CASE
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CreateEvents" Id="{4ed9832e-c5dc-46d4-abe9-a51eb498396c}">
      <Declaration><![CDATA[// Initializes event function blocks using this module's name
METHOD PROTECTED CreateEvents

// This method is called by Initialize() as required]]></Declaration>
      <Implementation>
        <ST><![CDATA[F_CreateAllEventsInClass(Alarms		:= MachineAlarms,
						 ClassSize	:= SIZEOF(TC_Events.MachineEvents),
						 pInitEvent := ADR(TC_EVENTS.MachineEvents.InitReferenceEvent),
						 Prefix		:= Name);

SUPER^.CreateEvents();]]></ST>
      </Implementation>
    </Method>
    <Method Name="CyclicLogic" Id="{e574dd6e-a801-487f-b62e-c8264bb86070}">
      <Declaration><![CDATA[// This method serves as the entry point for all underlying FB logic
METHOD PUBLIC CyclicLogic

// This method should be called cyclically by descendant function blocks by invoking SUPER^.CyclicLogic().  Alternatively, the contents of this method could be reimplemented entirely in which case a call to this method would not be necessary.
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT _InitComplete THEN
	_InitComplete := Initialize();
	RETURN;
END_IF

// AlarmHandling
IF testVerbose AND NOT MachineAlarms[E_MachineEvents.VerboseEvent].bRaised THEN
	RaiseAlarm2Args(MachineAlarms[E_MachineEvents.VerboseEvent], 'Note 1', 'Note 2');
END_IF

IF testCritical AND NOT MachineAlarms[E_MachineEvents.CriticalEvent].bRaised THEN
	RaiseAlarm2Args(MachineAlarms[E_MachineEvents.CriticalEvent], 'Note 1', 'Note 2');
END_IF

//The MachineMonitor is based on the SubModuleMonitor, but is only monitors itself
MachineMonitor();

//
SUPER^.CyclicLogic();

(*
*
*		Code must be after SUPER^.CyclicLogic();
*
*)

// Update alarm severity from this module 
_CurrentAlarmSeverity := F_GetMaxSeverityRaised(Alarms := MachineAlarms, CurrentSeverity := _CurrentAlarmSeverity);
_Error				  := _CurrentAlarmSeverity >= TcEventSeverity.Error;]]></ST>
      </Implementation>
    </Method>
    <Method Name="HMIPermissions" Id="{8e547c5b-7f21-4282-8bac-b6fb115570bc}">
      <Declaration><![CDATA[// Automatically enables and disables HMI control based on the PackML mode
METHOD PROTECTED HMIPermissions

// This method is called cyclically by CyclicLogic()]]></Declaration>
      <Implementation>
        <ST><![CDATA[AllowHMIControl(ThisModuleOnly := TRUE);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Initialize" Id="{d1725bba-8b00-4347-8fac-2b2ca6e24462}">
      <Declaration><![CDATA[// Basic module initialization logic
METHOD PROTECTED Initialize : BOOL;

// This method is called by CyclicLogic() as required]]></Declaration>
      <Implementation>
        <ST><![CDATA[Initialize := FALSE;
CASE DescendantSequenceState OF
	0:
		LogModeChanges	:= FALSE;
		LogStateChanges := FALSE;

		//Register Submodules
		RegisterSubmodule(EquipOne);
		RegisterSubmodule(EquipTwo);
		RegisterComponent(ComponentMM);
		DescendantSequenceState := DescendantSequenceState + 10;

	10:
		IF SUPER^.Initialize() THEN
			Initialize := TRUE;
		END_IF
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="MachineMonitor" Id="{8c8dc412-6c16-4a57-b8c9-8674903aa98b}">
      <Declaration><![CDATA[METHOD MachineMonitor
VAR
	AlarmResponses : ARRAY[0..4] OF E_AlarmResponse; //Temporary response array	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _CurrentState <> E_PMLState.Aborted AND _CurrentState <> E_PMLState.Aborting AND _CurrentState <> E_PMLState.Clearing AND _CurrentState <> E_PMLState.Stopped AND _CurrentState <> E_PMLState.Stopping THEN
	AlarmResponses := ParentResponseDefinitions;
	CASE AlarmResponses[_CurrentAlarmSeverity] OF
		E_AlarmResponse.Abort_ImmediateError:
			AbortImmediateError(Name, TRUE);

		E_AlarmResponse.Abort_Immediate:
			AbortImmediate();

		E_AlarmResponse.Stop_Immediate:
			StopImmediate();

		E_AlarmResponse.Stop_Controlled:
			StopControlled();

		E_AlarmResponse.Hold_Immediate:
			HoldImmediate();

		E_AlarmResponse.Hold_Controlled:
			HoldControlled();

		E_AlarmResponse.Suspend_Immediate:
			SuspendImmediate();

		E_AlarmResponse.Suspend_Controlled:
			SuspendControlled();

		E_AlarmResponse.NoResponse:
			;
	END_CASE
ELSIF _CurrentState = E_PMLState.Stopped OR _CurrentState = E_PMLState.Stopping THEN
	AlarmResponses := ParentResponseDefinitions;
	CASE AlarmResponses[CurrentAlarmSeverity] OF
		E_AlarmResponse.Abort_ImmediateError:
			AbortImmediateError(Name, TRUE);

		E_AlarmResponse.Abort_Immediate:
			AbortImmediate();

		E_AlarmResponse.NoResponse:
			;
	END_CASE
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="RaiseAlarm2Args" Id="{106a700c-ae28-40c8-8dd9-a78e7098e9ff}">
      <Declaration><![CDATA[METHOD RaiseAlarm2Args
VAR_IN_OUT
	Alarm : FB_TcAlarm; //Alarm to be raised
END_VAR

VAR_INPUT
	String_1 : STRING; //First String Parameter (The Name of this component will be applied first automatically)
	String_2 : STRING; //Second String Parameter
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[F_RaiseAlarmWithStringParameters(Alarm	  := Alarm,
								 String_1 := Name,
								 String_2 := String_1,
								 String_3 := String_2);]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>